[
  {
    "name": "Bubble Sort",
    "description": "Repeatedly swaps adjacent elements if they are in the wrong order, bubbling the largest values to the end.",
    "route": "/bubble-sort"
  },
  {
    "name": "Insertion Sort",
    "description": "Builds a sorted array one element at a time by inserting each new element into its correct position.",
    "route": "/insertion-sort"
  },
  {
    "name": "Selection Sort",
    "description": "Selects the smallest element from the unsorted portion and swaps it into its correct position each iteration.",
    "route": "/selection-sort"
  },
  {
    "name": "Shell Sort",
    "description": "An optimization of insertion sort that starts by comparing elements far apart and gradually reduces the gap, improving efficiency for larger arrays.",
    "route": "/shell-sort"
  },
  {
    "name": "Quick Sort",
    "description": "Divides the array using a pivot, then recursively sorts the partitions. Efficient for large datasets with average O(n log n) time complexity.",
    "route": "/quick-sort"
  },
  {
    "name": "Merge Sort",
    "description": "Divides the array into halves recursively, then merges the sorted halves back together. Guarantees O(n log n) time complexity and is stable.",
    "route": "/merge-sort"
  },
  {
    "name": "Heap Sort",
    "description": "Builds a max heap from the array, then repeatedly extracts the largest element to sort the array. Efficient O(n log n) time complexity but unstable.",
    "route": "/heap-sort"
  },
  {
    "name": "Tim Sort",
    "description": "A hybrid sorting algorithm that combines insertion sort for small runs and merge sort for merging them. Efficient, stable, and used in Python and Javaâ€™s built-in sorts.",
    "route": "/tim-sort"
  },
  {
    "name": "Counting Sort",
    "description": "A non-comparison-based algorithm that counts occurrences of each value to determine their correct positions. Works best for integers within a limited range.",
    "route": "/counting-sort"
  },
  {
    "name": "Radix Sort",
    "description": "Sorts numbers digit by digit, often using counting sort as a subroutine. Efficient for large datasets of integers with limited digit length.",
    "route": "/radix-sort"
  },
  {
    "name": "Bucket Sort",
    "description": "Distributes elements into multiple buckets, then sorts each bucket individually (often with insertion sort) before merging them. Useful for uniformly distributed data.",
    "route": "/bucket-sort"
  }
]